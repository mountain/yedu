<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç†æƒ³å¤§é™†æ°”å€™æœºåˆ¶æ¨¡æ‹Ÿå™¨ (Toy Model)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h2 { color: #333; }
        .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); width: 800px; margin-bottom: 20px; display: flex; gap: 20px; align-items: center; }
        canvas { background: #fff; box-shadow: 0 4px 15px rgba(0,0,0,0.1); cursor: crosshair; }
        .label { font-weight: bold; width: 60px; }
        input[type=range] { flex-grow: 1; }
        .info-panel { margin-top: 10px; font-family: monospace; color: #555; }
        .legend { display: flex; gap: 15px; font-size: 12px; margin-top: 5px;}
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .box { width: 12px; height: 12px; }
    </style>
</head>
<body>

    <h2>ç†æƒ³å¤§é™†æ°”å€™æœºåˆ¶æ¨¡æ‹Ÿå™¨ (Toy Model)</h2>

    <div class="controls">
        <div class="label">æœˆä»½:</div>
        <input type="range" id="monthSlider" min="0" max="11" step="0.1" value="0">
        <div id="monthDisplay" class="label">1æœˆ</div>
        <button onclick="toggleAnim()">â¯ æ’­æ”¾/æš‚åœ</button>
    </div>

    <canvas id="simCanvas" width="800" height="500"></canvas>

    <div class="legend">
        <div class="legend-item"><div class="box" style="background:#aaddff"></div>æµ·æ´‹</div>
        <div class="legend-item"><div class="box" style="background:#e0e0e0"></div>å¤§é™†(å¹²)</div>
        <div class="legend-item"><div class="box" style="background:#44aa44"></div>å¤§é™†(æ¹¿/æ¤è¢«)</div>
        <div class="legend-item">ğŸ”µ é™é›¨åŒºåŸŸ</div>
        <div class="legend-item">â¡ é£å‘</div>
    </div>

    <div class="info-panel" id="debugInfo">é¼ æ ‡æ‚¬åœæŸ¥çœ‹è¯¦ç»†å‚æ•°...</div>

<script>
/**
 * æ ¸å¿ƒé€»è¾‘ï¼šæ˜ç†ï¼Œè¿™é‡Œæ˜¯æˆ‘ä»¬è®¨è®ºçš„ç‰©ç†æœºåˆ¶çš„ä»£ç åŒ–ã€‚
 * æˆ‘ä»¬ä¸»è¦æ¨¡æ‹Ÿï¼š
 * 1. æ°”å‹å¸¦éšå­£èŠ‚ç§»åŠ¨ (Belt Shift)
 * 2. é£å‘åˆ¤å®š (Wind Vector)
 * 3. é™æ°´åˆ¤å®š (Precipitation = Convection + Advection)
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const width = 800;
const height = 500;
const cols = 40;
const rows = 25;
const cellW = width / cols;
const cellH = height / rows;

// çŠ¶æ€å˜é‡
let month = 0; // 0-11
let animating = true;

// ç†æƒ³å¤§é™†å®šä¹‰ (ä¸­é—´ä¸€å—çŸ©å½¢)
const landMask = new Array(cols * rows).fill(0);
for(let y = 5; y < rows - 5; y++) {
    for(let x = 10; x < cols - 10; x++) {
        landMask[y * cols + x] = 1;
    }
}

// è¾…åŠ©å‡½æ•°ï¼šå°†ç½‘æ ¼Yåæ ‡è½¬æ¢ä¸ºçº¬åº¦ (-90 ~ 90)
function getLat(y) {
    return 90 - (y / rows) * 180;
}

// æ ¸å¿ƒç‰©ç†è®¡ç®—
function calculateCell(x, y, currentMonth) {
    const lat = getLat(y);
    const isLand = landMask[y * cols + x] === 1;

    // 1. å­£èŠ‚åç§»å› å­ (Seasonality)
    // å¤ªé˜³ç›´å°„ç‚¹åœ¨ -23.5 åˆ° 23.5 ä¹‹é—´ç§»åŠ¨ã€‚æ»åçº¦1ä¸ªæœˆã€‚
    // month 0 = Jan (Winter in NH), month 6 = July (Summer in NH)
    const seasonOffset = -23.5 * Math.cos((currentMonth / 12) * 2 * Math.PI);

    // æ°”å‹å¸¦ä¸­å¿ƒ (éšå­£èŠ‚ç§»åŠ¨)
    const itczLat = seasonOffset; // èµ¤é“ä½å‹å¸¦
    const subHighLatN = 30 + seasonOffset * 0.5; // å‰¯é«˜ç§»åŠ¨å¹…åº¦é€šå¸¸æ¯”ç›´å°„ç‚¹å°
    const subHighLatS = -30 + seasonOffset * 0.5;

    // 2. åŸºç¡€è¡Œæ˜Ÿé£ç³» (Planetary Wind)
    let u = 0; // çº¬å‘é£ (æ­£=è¥¿é£, è´Ÿ=ä¸œé£)
    let v = 0; // ç»å‘é£ (æ­£=å—é£, è´Ÿ=åŒ—é£)

    // ç®€å•ä¸‰åœˆç¯æµé€»è¾‘
    if (Math.abs(lat - itczLat) < 10) {
        // èµ¤é“æ— é£å¸¦/ä¸Šå‡æ°”æµ
        u = -2; // å¼±ä¸œé£
    } else if (lat > subHighLatN + 5 || lat < subHighLatS - 5) {
        // ä¸­çº¬åº¦è¥¿é£å¸¦ (Westerlies)
        u = 8;
        v = (lat > 0) ? 2 : -2; // ç•¥å¾®åæåœ°
    } else {
        // ä½çº¬åº¦ä¿¡é£å¸¦ (Trade Winds)
        u = -8; // ä¸œé£
        v = (lat > 0) ? -2 : 2; // æŒ‡å‘èµ¤é“
    }

    // 3. å­£é£æ•ˆåº” (Monsoon Effect - Thermal Contrast)
    // å¤å­£å¤§é™†çƒ­ -> ä½å‹ -> å¸é£; å†¬å­£å¤§é™†å†· -> é«˜å‹ -> å¹é£
    if (isLand || isCoastal(x,y)) {
        const landTempDiff = (lat > 0) ? Math.sin(((currentMonth-3)/12)*2*Math.PI) : Math.sin(((currentMonth-9)/12)*2*Math.PI);
        // å¦‚æœ landTempDiff > 0 (Summer), é™†åœ°ä½å‹, é£å¹å‘å†…é™†
        // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„æ‰°åŠ¨åœº
        // è¿™é‡Œä¸»è¦æ¨¡æ‹Ÿä¸œå²¸çš„å­£é£æ˜¾è‘—æ€§
        if (x > cols/2) { // ä¸œåŠéƒ¨
             u += landTempDiff * -5; // å¤å­£åŠ å¼ºä¸œé£(æµ·->é™†), å†¬å­£åŠ å¼ºè¥¿é£(é™†->æµ·)
        }
    }

    // 4. é™æ°´åˆ¤å®š (Precipitation Logic)
    let precip = 0;

    // A. å¯¹æµé›¨ (ITCZ)
    if (Math.abs(lat - itczLat) < 8) precip += 10;

    // B. é”‹é¢é›¨ (è¥¿é£å¸¦)
    if (Math.abs(lat) > 40 && Math.abs(lat) < 65) precip += 5;

    // C. å‰¯é«˜æ§åˆ¶ (ä¸‹æ²‰å¹²æ—±)
    if (Math.abs(lat - subHighLatN) < 8 || Math.abs(lat - subHighLatS) < 8) precip -= 10;

    // D. åœ°å½¢/å¹³æµé›¨ (Advection)
    // æ£€æŸ¥ä¸Šæ¸¸ç½‘æ ¼æ˜¯å¦æ˜¯æµ·æ´‹ã€‚å¦‚æœæ˜¯æµ·é£å¹å‘é™†åœ° -> æ¹¿ã€‚é™†å¹å‘æµ· -> å¹²ã€‚
    let upstreamIsSea = false;
    if (u > 0) { // è¥¿é£ï¼Œçœ‹å·¦è¾¹
        upstreamIsSea = (x > 0 && landMask[y*cols + (x-1)] === 0);
    } else { // ä¸œé£ï¼Œçœ‹å³è¾¹
        upstreamIsSea = (x < cols-1 && landMask[y*cols + (x+1)] === 0);
    }

    if (isLand && upstreamIsSea) precip += 8; // è¿é£å¡
    if (isLand && !upstreamIsSea) precip -= 5; // ç¦»å²¸é£æˆ–å†…é™†

    // å½’ä¸€åŒ–
    if (precip < 0) precip = 0;

    return { lat, isLand, u, v, precip };
}

// è¾…åŠ©ï¼šåˆ¤æ–­æ˜¯å¦åœ¨æµ·å²¸çº¿é™„è¿‘
function isCoastal(x, y) {
    if (landMask[y*cols+x] === 1) return false;
    // ç®€å•æ£€æŸ¥é‚»å±…
    return (x>0 && landMask[y*cols+x-1]) || (x<cols-1 && landMask[y*cols+x+1]);
}

function draw() {
    ctx.clearRect(0, 0, width, height);

    for(let y = 0; y < rows; y++) {
        for(let x = 0; x < cols; x++) {
            const cell = calculateCell(x, y, month);

            // ç»˜åˆ¶åº•è‰² (Land vs Ocean)
            if (cell.isLand) {
                // æ ¹æ®é™æ°´æ”¹å˜é™†åœ°é¢œè‰² (Visualizing Climate Type)
                if (cell.precip > 5) ctx.fillStyle = "#44aa44"; // æ¹¿æ¶¦/æ£®æ—
                else if (cell.precip > 2) ctx.fillStyle = "#aaaa44"; // è‰åŸ
                else ctx.fillStyle = "#e0e0e0"; // è’æ¼ 
            } else {
                ctx.fillStyle = "#aaddff"; // æµ·æ´‹
            }
            ctx.fillRect(x*cellW, y*cellH, cellW, cellH);

            // ç»˜åˆ¶é™æ°´ (Rain overlay)
            if (cell.precip > 0) {
                ctx.fillStyle = `rgba(0, 0, 255, ${Math.min(cell.precip / 15, 0.6)})`;
                ctx.fillRect(x*cellW, y*cellH, cellW, cellH);
            }

            // ç»˜åˆ¶é£åœºç®­å¤´ (Wind Vectors)
            // ä¸ºäº†è§†è§‰æ¸…æ™°ï¼Œä¸ç”¨æ¯ä¸ªæ ¼å­éƒ½ç”»
            if (x % 2 === 0 && y % 2 === 0) {
                drawArrow(ctx, x*cellW + cellW/2, y*cellH + cellH/2, cell.u, cell.v);
            }
        }
    }

    // ç»˜åˆ¶çº¬åº¦çº¿å’Œæ ‡è®°
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.beginPath();
    // èµ¤é“
    let eqY = height / 2;
    ctx.moveTo(0, eqY); ctx.lineTo(width, eqY);
    ctx.stroke();
    ctx.fillStyle = "#000";
    ctx.fillText("0Â°", 5, eqY - 2);

    // 30åº¦
    let h30 = height * (60/180);
    ctx.fillText("30Â°N", 5, h30 - 2);
    ctx.fillText("30Â°S", 5, height - h30 - 2);

    updateUI();
}

function drawArrow(ctx, x, y, u, v) {
    const mag = Math.sqrt(u*u + v*v);
    if (mag < 0.1) return;

    const scale = 1.5; // ç®­å¤´é•¿åº¦ç¼©æ”¾
    const angle = Math.atan2(v, u);

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(-5 * scale, 0);
    ctx.lineTo(5 * scale, 0);
    ctx.lineTo(2 * scale, -2 * scale);
    ctx.moveTo(5 * scale, 0);
    ctx.lineTo(2 * scale, 2 * scale);
    ctx.strokeStyle = "rgba(0,0,0,0.5)";
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
}

function updateUI() {
    document.getElementById('monthDisplay').innerText = Math.floor(month + 1) + "æœˆ";
    document.getElementById('monthSlider').value = month;
}

function loop() {
    if (animating) {
        month += 0.05;
        if (month >= 12) month = 0;
    }
    draw();
    requestAnimationFrame(loop);
}

// äº¤äº’æ§åˆ¶
document.getElementById('monthSlider').addEventListener('input', (e) => {
    month = parseFloat(e.target.value);
    animating = false; // ç”¨æˆ·æ‹–åŠ¨æ—¶æš‚åœ
    draw();
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / cellW);
    const y = Math.floor((e.clientY - rect.top) / cellH);
    if (x >=0 && x < cols && y >=0 && y < rows) {
        const cell = calculateCell(x, y, month);
        const lat = Math.round(cell.lat);
        document.getElementById('debugInfo').innerText =
            `Lat: ${lat}Â° | ç±»å‹: ${cell.isLand?'é™†åœ°':'æµ·æ´‹'} | é£é€Ÿ U:${cell.u.toFixed(1)} | é™æ°´æŒ‡æ•°: ${cell.precip.toFixed(1)}`;
    }
});

function toggleAnim() {
    animating = !animating;
    if (animating) loop();
}

// å¯åŠ¨
landMask[10] = 0; // æµ‹è¯•
loop();

</script>
</body>
</html>