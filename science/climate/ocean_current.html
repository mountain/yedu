<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç†æƒ³å¤§æ´‹ç¯æµæ¨¡å‹ï¼šé£åº”åŠ›ä¸è¥¿è¾¹ç•Œå¼ºåŒ–</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #001f3f; color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h2 { margin-bottom: 5px; color: #7FDBFF; }
        .subtitle { font-size: 0.9em; color: #aaa; margin-bottom: 20px; }
        canvas { background: #001f3f; border-radius: 4px; box-shadow: 0 0 20px rgba(0,255,255,0.1); cursor: crosshair; }
        .controls { margin-top: 15px; display: flex; gap: 20px; background: rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 20px; }
        .legend { margin-top: 15px; font-size: 12px; display: flex; gap: 15px; color: #ddd; }
        .legend-item span { display: inline-block; width: 10px; height: 10px; margin-right: 5px; border-radius: 50%; }
        #debug { font-family: monospace; margin-top: 10px; color: #7FDBFF; min-height: 20px; }
    </style>
</head>
<body>

    <h2>ç†æƒ³å¤§æ´‹ç¯æµæ¨¡å‹ (Wind-Driven Circulation)</h2>
    <div class="subtitle">åŸºäº Stommel æ¨¡å‹æ¼”ç¤ºï¼šè¥¿è¾¹ç•Œå¼ºåŒ–(é»‘æ½®/æ¹¾æµ) vs ä¸œè¾¹ç•Œå¯’æµ</div>

    <canvas id="oceanCanvas" width="800" height="500"></canvas>

    <div class="controls">
        <label><input type="checkbox" id="showVectors" checked> æ˜¾ç¤ºæµçº¿çŸ¢é‡</label>
        <label><input type="checkbox" id="showTemp" checked> æ˜¾ç¤ºæ¸©åº¦ç€è‰²</label>
        <button onclick="resetParticles()">ğŸ”„ é‡ç½®ç²’å­</button>
    </div>

    <div class="legend">
        <div class="legend-item"><span style="background:#ff3333"></span>æš–æµ (è¥¿è¾¹ç•Œ/èµ¤é“)</div>
        <div class="legend-item"><span style="background:#33ccff"></span>å¯’æµ (ä¸œè¾¹ç•Œ/æåœ°)</div>
        <div class="legend-item"><span style="background:#888"></span>å¤§é™†</div>
    </div>

    <div id="debug">é¼ æ ‡æ‚¬åœæŸ¥çœ‹æµé€Ÿä¸æ€§è´¨...</div>

<script>
const canvas = document.getElementById('oceanCanvas');
const ctx = canvas.getContext('2d');
const width = 800;
const height = 500;

// æ¨¡æ‹Ÿå‚æ•°
const particles = [];
const numParticles = 2500;
const cols = 80;
const rows = 50;
const cellW = width / cols;
const cellH = height / rows;

// å¤§é™†å®šä¹‰ (è¿™æ¬¡å¤§é™†åœ¨ä¸­é—´ï¼Œä¸¤è¾¹æ˜¯æµ·ï¼Œæ¨¡æ‹Ÿå¤§è¥¿æ´‹æˆ–å¤ªå¹³æ´‹)
// ä¸ºäº†æ¼”ç¤ºæ´‹æµç¯æµï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé—­åˆçš„å¤§æ´‹ç›†åœ°ã€‚
// è®©æˆ‘ä»¬è®¾å®šï¼šå·¦è¾¹æ˜¯"æ¬§äºšå¤§é™†ä¸œå²¸"ï¼Œå³è¾¹æ˜¯"åŒ—ç¾å¤§é™†è¥¿å²¸"ã€‚
// æ‰€ä»¥ä¸­é—´æ˜¯ä¸€ç‰‡å¤§æ´‹ã€‚
const oceanWidth = width * 0.8;
const oceanStart = width * 0.1;
const oceanEnd = width * 0.9;

// é¢„è®¡ç®—æµåœº (Velocity Field)
const field = new Array(cols * rows).fill(null);

function initField() {
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            const px = x * cellW;
            const py = y * cellH;

            // å½’ä¸€åŒ–åæ ‡ (0 åˆ° 1) ç”¨äºè®¡ç®— Stommel è§£
            // ä»…åœ¨æµ·æ´‹åŒºåŸŸè®¡ç®—
            let u = 0, v = 0;
            let isOcean = false;

            if (px > oceanStart && px < oceanEnd) {
                isOcean = true;
                // å½’ä¸€åŒ–å¤§æ´‹åæ ‡ X (0=è¥¿è¾¹ç•Œ, 1=ä¸œè¾¹ç•Œ)
                const nx = (px - oceanStart) / (oceanEnd - oceanStart);
                // å½’ä¸€åŒ–çº¬åº¦ Y (0=å—æ, 0.5=èµ¤é“, 1=åŒ—æ)
                const ny = 1 - (py / height);
                const lat = (ny - 0.5) * 180; // -90 ~ 90

                // --- Stommel æ¨¡å‹æ ¸å¿ƒé€»è¾‘ ---
                // æˆ‘ä»¬æ„å»ºä¸¤ä¸ª Gyre (ç¯æµåœˆ)
                // åŒ—åŠçƒå‰¯çƒ­å¸¦ (15-45N): é¡ºæ—¶é’ˆ
                // åŒ—åŠçƒå‰¯æåœ° (45-75N): é€†æ—¶é’ˆ
                // èµ¤é“ç³»ç»Ÿ (0-15N)

                let amplitude = 0;
                let direction = 0; // 1 = Clockwise, -1 = Counter

                // å®šä¹‰åŒºåŸŸå¼ºåº¦
                if (lat > 10 && lat < 50) { // å‰¯çƒ­å¸¦ç¯æµ (Subtropical Gyre)
                    amplitude = Math.sin(((lat - 10) / 40) * Math.PI);
                    direction = 1; // é¡ºæ—¶é’ˆ
                } else if (lat >= 50 && lat < 80) { // å‰¯æåœ°ç¯æµ (Subpolar Gyre)
                    amplitude = Math.sin(((lat - 50) / 30) * Math.PI) * 0.6; // å¼±ä¸€ç‚¹
                    direction = -1; // é€†æ—¶é’ˆ
                } else if (lat > -50 && lat < -10) { // å—åŠçƒå‰¯çƒ­å¸¦
                    amplitude = Math.sin(((Math.abs(lat) - 10) / 40) * Math.PI);
                    direction = -1; // å—åŠçƒåæ°”æ—‹æ˜¯é€†æ—¶é’ˆ
                }

                if (amplitude > 0) {
                    // Stommel è¥¿è¾¹ç•Œå¼ºåŒ–å› å­
                    // f(x) = (1 - x/L) - e^(-x/epsilon)
                    // ç®€å•æ¨¡æ‹Ÿï¼šè¥¿è¾¹æµé€Ÿæå¤§ï¼ŒæŒ‡æ•°è¡°å‡

                    // åŸºç¡€ç¯æµ (Sverdrup å†…éƒ¨è§£ - çº¿æ€§å˜åŒ–)
                    // const baseFlow = Math.sin(nx * Math.PI);

                    // å¼ºåŒ–åçš„æµå‡½æ•° Psi
                    // è¿™é‡Œçš„æ•°å­¦ä¸å¿…å¤ªä¸¥è°¨ï¼Œå…³é”®æ˜¯å½¢æ€ï¼š
                    // è¥¿è¾¹(nxæ¥è¿‘0)æ¢¯åº¦å¤§ï¼Œä¸œè¾¹æ¢¯åº¦å°
                    const intensification = 0.05; // è¶Šå°è¶Šå¼ºåŒ–
                    const stommelX = (1 - Math.exp(-nx/intensification)) - nx;

                    // Psi = Amplitude(y) * Structure(x)
                    // u = -dPsi/dy, v = dPsi/dx

                    // ç®€åŒ–ï¼šç›´æ¥æ„é€ é€Ÿåº¦åœº
                    // è¥¿è¾¹ç•Œå¼ºåŒ—å‘æµ (Western Boundary Current)
                    const westJet = Math.exp(-nx / 0.08) * 4.0;
                    // å†…éƒ¨å›æµ (Sverdrup Interior)
                    const returnFlow = -0.3; // ç¼“æ…¢å‘å—å›æµ

                    // ç»å‘é€Ÿåº¦ V (å—åŒ—)
                    let baseV = (westJet + returnFlow);

                    // çº¬å‘é€Ÿåº¦ U (ä¸œè¥¿) - ä¿æŒè´¨é‡å®ˆæ’(div V = 0)çš„è¿‘ä¼¼
                    // åœ¨ç¯æµé¡¶éƒ¨å’Œåº•éƒ¨è½¬å¼¯
                    let baseU = 0;

                    // é¡¶éƒ¨è½¬å¼¯å‘ä¸œ
                    // åº•éƒ¨è½¬å¼¯å‘è¥¿
                    // è¿™é‡Œç”¨ç®€å•çš„æ—‹è½¬é€»è¾‘å åŠ 

                    // è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªæ›´ç›´è§‚çš„çŸ¢é‡æ—‹è½¬æ³•ï¼š
                    // ä¸­å¿ƒç‚¹
                    let cx = 0.5; // å¤§æ´‹ä¸­å¿ƒ
                    if (direction === 1) cx = 0.15; // é¡ºæ—¶é’ˆç¯æµä¸­å¿ƒæåº¦åè¥¿!
                    else cx = 0.15; // é€†æ—¶é’ˆç¯æµä¸­å¿ƒä¹Ÿåè¥¿

                    const dx = nx - cx;
                    // Yè½´ä¸­å¿ƒæ ¹æ®ç¯æµå¸¦è°ƒæ•´
                    let cy_lat = 0;
                    if (lat > 0) cy_lat = (lat > 45) ? 65 : 30;
                    else cy_lat = -30;

                    const cy = (cy_lat + 90) / 180;
                    const dy = (ny - cy) * 2.0; // Yè½´æ‹‰ä¼¸ä¸€ä¸‹

                    // åŸºç¡€æ—‹è½¬ velocity
                    // v_tan = r * dir
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    let speed = amplitude * 2 * Math.exp(-dist * 2);

                    // å åŠ è¥¿è¾¹ç•Œå¼ºåŒ–ç‰¹å¾
                    // å¦‚æœåœ¨è¥¿è¾¹ (nx < 0.1), v åˆ†é‡æå¤§
                    if (nx < 0.1) speed *= (3.0 / (nx + 0.05));

                    // è®¡ç®— u, v
                    // é¡ºæ—¶é’ˆ: (y, -x)
                    // è¥¿è¾¹ç•Œå¼ºåŒ–å¯¼è‡´æµçº¿å‹ç¼©
                    // æˆ‘ä»¬æ‰‹åŠ¨æ„å»ºï¼š
                    // è¥¿è¾¹ç•Œ(nx<0.1): å¼º V
                    // å…¶ä»–: å¼± V, ä¸­ç­‰ U

                    if (direction === 1) { // åŒ—åŠçƒå‰¯çƒ­å¸¦ (é¡ºæ—¶é’ˆ)
                        // è¥¿å²¸åŒ—ä¸Š
                        if (nx < 0.15) { u = 0.5 * nx; v = 5.0 * (1-ny)*Math.exp(-nx/0.05); }
                        // åŒ—éƒ¨ä¸œè¡Œ (è¥¿é£æ¼‚æµ)
                        else if (lat > 40) { u = 3.0; v = -0.5; }
                        // ä¸œå²¸å—ä¸‹ (åŠ åˆ©ç¦å°¼äºšå¯’æµ - æ…¢)
                        else if (nx > 0.8) { u = -0.2; v = -1.0; }
                        // å—éƒ¨è¥¿è¡Œ (åŒ—èµ¤é“æš–æµ)
                        else if (lat < 20) { u = -2.5; v = 0.2; }
                        // ä¸­é—´
                        else { u = 0.2; v = -0.2; }
                    } else if (direction === -1 && lat > 0) { // åŒ—åŠçƒå‰¯æåœ° (é€†æ—¶é’ˆ)
                        // è¥¿å²¸å—ä¸‹ (äº²æ½®)
                        if (nx < 0.15) { u = 0.5; v = -3.0 * Math.exp(-nx/0.05); }
                        // å—éƒ¨ä¸œè¡Œ
                        else if (lat < 55) { u = 2.0; v = 0.5; }
                        // é¡¶éƒ¨è¥¿è¡Œ (æåœ°ä¸œé£)
                        else { u = -1.0; v = -0.5; }
                    } else { // å—åŠçƒ (é€†æ—¶é’ˆ)
                         // è¥¿å²¸å—ä¸‹ (å·´è¥¿/ä¸œæ¾³æš–æµ) - å¼º
                        if (nx < 0.15) { u = 0.5; v = -5.0 * Math.exp(-nx/0.05); }
                        // å—éƒ¨ä¸œè¡Œ (è¥¿é£æ¼‚æµ) - æå¼º
                        else if (lat < -40) { u = 5.0; v = 0.1; }
                        // ä¸œå²¸åŒ—ä¸Š (ç§˜é²/æœ¬å‰æ‹‰å¯’æµ) - æ…¢
                        else if (nx > 0.8) { u = -0.5; v = 1.5; }
                        // åŒ—éƒ¨è¥¿è¡Œ (å—èµ¤é“æš–æµ)
                        else { u = -2.5; v = -0.2; }
                    }
                }

                // èµ¤é“é€†æµ (Doldrums)
                if (Math.abs(lat) < 5) {
                    u = 3.0; v = 0;
                }
            }

            field[y * cols + x] = { u, v, isOcean, lat: 90 - (y/rows)*180 };
        }
    }
}

// ç²’å­ç³»ç»Ÿ
class Particle {
    constructor() {
        this.reset();
    }

    reset() {
        // éšæœºåˆ†å¸ƒåœ¨æµ·æ´‹åŒºåŸŸ
        this.x = oceanStart + Math.random() * (oceanEnd - oceanStart);
        this.y = Math.random() * height;
        const distFromEquator = Math.abs(this.y - height / 2);
        const maxDist = height / 2;
        this.temp = 1 - (distFromEquator / maxDist);
        this.age = 0;
        this.life = 200 + Math.random() * 200;
    }

    update() {
        const c = Math.floor(this.x / cellW);
        const r = Math.floor(this.y / cellH);

        if (c >= 0 && c < cols && r >= 0 && r < rows) {
            const f = field[r * cols + c];
            if (f && f.isOcean) {
                this.x += f.u;
                this.y -= f.v; // Canvas Y is inverted relative to North

                // æ¸©åº¦å¹³æµ (Advection)
                // ç²’å­è¯•å›¾é€‚åº”å½“å‰çº¬åº¦çš„â€œç¯å¢ƒæ¸©åº¦â€ï¼Œä½†æœ‰æ»åæ€§ï¼ˆçƒ­æƒ¯æ€§ï¼‰
                // è¿™å¯¼è‡´äº†ï¼šä»èµ¤é“æ¥çš„æ°´åœ¨åˆ°äº†é«˜çº¬åº¦ä¾ç„¶æ˜¯æš–çš„ï¼ˆæš–æµï¼‰
                // ä»æåœ°æ¥çš„æ°´åˆ°äº†ä½çº¬åº¦ä¾ç„¶æ˜¯å†·çš„ï¼ˆå¯’æµï¼‰
                const distFromEquator = Math.abs(this.y - height / 2);
                const maxDist = height / 2;
                const ambientTemp = 1 - (distFromEquator / maxDist);
                // å…³é”®å‚æ•°ï¼šçƒ­äº¤æ¢é€Ÿç‡ã€‚è¶Šæ…¢ï¼Œæš–æµå»¶ä¼¸è¶Šè¿œ
                const heatExchangeRate = 0.01;
                this.temp = this.temp * (1 - heatExchangeRate) + ambientTemp * heatExchangeRate;

            } else {
                this.reset(); // Hit land
            }
        } else {
            this.reset(); // Out of bounds
        }

        this.age++;
        if (this.age > this.life) this.reset();

        // Wrap around vertically just in case
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
    }

    draw() {
        // Color based on temp
        // Blue (0) -> Cyan -> Green -> Yellow -> Red (1)
        // Simple HSL: Blue is 240, Red is 0.
        // Let's map 0->240 (Cold), 1->0 (Warm)

        // è§†è§‰ä¿®æ­£ï¼šè®©å¯’æµæ›´è“ï¼Œæš–æµæ›´çº¢
        let hue = 240 - (this.temp * 240);
        // Saturation
        ctx.fillStyle = `hsla(${hue}, 80%, 50%, 0.6)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

function initParticles() {
    for(let i=0; i<numParticles; i++) particles.push(new Particle());
}

function resetParticles() {
    particles.forEach(p => p.reset());
}

function drawMap() {
    // Draw Continents
    ctx.fillStyle = "#222";
    // Left Continent (Asia/Australia)
    ctx.fillRect(0, 0, oceanStart, height);
    // Right Continent (Americas)
    ctx.fillRect(oceanEnd, 0, width - oceanEnd, height);

    // Draw Latitudes
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.beginPath();
    [height/2, height*0.25, height*0.75].forEach(y => {
        ctx.moveTo(oceanStart, y); ctx.lineTo(oceanEnd, y);
    });
    ctx.stroke();

    // Text
    ctx.fillStyle = "#555";
    ctx.fillText("West Continent (e.g. Asia)", 10, height/2);
    ctx.fillText("East Continent (e.g. USA)", oceanEnd + 10, height/2);
    ctx.fillText("30Â°N", oceanEnd - 40, height*0.25 - 5);
    ctx.fillText("0Â°", oceanEnd - 40, height*0.5 - 5);
}

function drawVectors() {
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    for (let y = 2; y < rows; y+=2) {
        for (let x = 0; x < cols; x+=2) {
            const f = field[y * cols + x];
            if (f && f.isOcean && (Math.abs(f.u) > 0.1 || Math.abs(f.v) > 0.1)) {
                const px = x * cellW + cellW/2;
                const py = y * cellH + cellH/2;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + f.u * 4, py - f.v * 4);
                ctx.stroke();
            }
        }
    }
}

function animate() {
    // Trail effect
    ctx.fillStyle = "rgba(0, 31, 63, 0.2)"; // Ocean dark blue background
    ctx.fillRect(oceanStart, 0, oceanEnd-oceanStart, height);

    // Re-draw map overlay boundaries
    ctx.fillStyle = "#111"; // Land color
    ctx.fillRect(0, 0, oceanStart, height);
    ctx.fillRect(oceanEnd, 0, width - oceanEnd, height);

    if (document.getElementById('showVectors').checked) {
        drawVectors();
    }

    particles.forEach(p => {
        p.update();
        if (document.getElementById('showTemp').checked) {
            p.draw();
        } else {
             ctx.fillStyle = "rgba(200,200,255,0.6)";
             ctx.beginPath(); ctx.arc(p.x, p.y, 1.5, 0, Math.PI*2); ctx.fill();
        }
    });

    requestAnimationFrame(animate);
}

// äº¤äº’
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (x > oceanStart && x < oceanEnd) {
        const c = Math.floor(x / cellW);
        const r = Math.floor(y / cellH);
        const f = field[r*cols+c];
        if (f) {
            let type = "";
            if (f.v > 1.0) type = "å¿«é€ŸåŒ—å‘æš–æµ (å¦‚é»‘æ½®/æ¹¾æµ)";
            else if (f.v < -0.5 && x > width/2) type = "ç¼“æ…¢å—å‘å¯’æµ (å¦‚åŠ å·/åŠ é‚£åˆ©)";
            else if (Math.abs(f.lat) < 5) type = "èµ¤é“æµç³»";
            else if (Math.abs(f.u) > 2) type = "è¥¿é£æ¼‚æµ";

            document.getElementById('debug').innerHTML =
                `Lat: ${f.lat.toFixed(1)} | U: ${f.u.toFixed(1)} V: ${f.v.toFixed(1)} | ${type}`;
        }
    } else {
        document.getElementById('debug').innerHTML = "é™†åœ°";
    }
});

// Start
initField();
initParticles();
animate();

</script>
</body>
</html>